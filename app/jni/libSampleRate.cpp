#include <cstdlib>
#include <android/log.h>
#include <cstring>
#include "libSampleRate.h"
#include <thread>
#include "GlobalTools.h"

// These statics keep the resampling state alive across calls so repeated
// invocations from the TTS engine avoid costly allocations. Keeping buffers
// warm helps maintain smooth feedback for TalkBack users who rely on rapid
// speech output.
static int nMessagePrintCounter = 0;
static SRC_STATE *mPointerSRCState = nullptr;
static short *mShortInput = nullptr;
static float *mFloatInput = nullptr;
static float *mFloatOutput = nullptr;
static short *mShortOutput = nullptr;
static float *mFloatOutputResult = nullptr;
static int mLenInput = 0;
static int mLenOutput = 0;
static bool mIsLoaded = false;
// Protects thread count and wait variables below.
static /*mutable*/ pthread_mutex_t mThreadCountLock;
// ISSUE: these globals are mutated across JNI calls without consistently
// locking mThreadCountLock, so concurrent resample() invocations can
// corrupt shared buffers and state.

/*
 * https://stackoverflow.com/questions/26603285/return-byte-array-in-jni-android
            jbyte a[] = {1,2,3,4,5,6};
        jbyteArray ret = env->NewByteArray(6);
        env->SetByteArrayRegion (ret, 0, 6, a);
        return ret;
    https://stackoverflow.com/questions/55585908/how-to-release-the-returned-object-in-jni
    according to this source if bytearray was as input argument , but ReleaseByteArrayElements must called
    I change the input variable as clone
    https://stackoverflow.com/questions/20268170/do-i-need-to-release-jni-array-that-i-modify-and-return
    You need to release array elements due to JVM marks
    it as "used in native code" when you get elements by GetFloatArrayElements(..) function
*/
void JNI_OnLoadManual(JavaVM *vm, void *reserved) {
    // Initialise the mutex on demand so callers can opt-in without relying on
    // the automatic JNI_OnLoad callback generated by the build system.
    if (pthread_mutex_init(&mThreadCountLock, nullptr) != 0) {
        CGlobalTools::AndroidLog("com.khanenoor.parsavatts",
                            "mutex init has failed");

    }
}

void JNI_OnUnloadManual(JavaVM *vm, void *reserved) {
    CGlobalTools::AndroidLog(
                        "com.khanenoor.parsavatts",
                        "JNI_OnUnloadManual");
    unloadResample();
    pthread_mutex_destroy(&mThreadCountLock);
}

extern "C" JNIEXPORT jbyteArray
JNICALL Java_com_khanenoor_parsavatts_engine_EnTts_resample(JNIEnv *env, jobject thiz, jbyteArray
dataIn,
                                                     jint inSampleFreq,
                                                     jint outSampleFreq,
                                                     jint inChannels,
                                                     jint outChannels,
                                                     jfloat volumeRatio
) {
    // Use a stack SRC_DATA so repeated calls from Java never leak state.
    SRC_DATA src_data;
    int nSRCErrorCode;
    jbyteArray dataOut = nullptr;
    jbyte *byteDataIn = nullptr;
    try {
        //pthread_mutex_lock(&mThreadCountLock);
        if (mPointerSRCState != nullptr) {
            int output_count = 0;
            // Input length is reported in bytes, so divide by two when
            // converting to 16-bit PCM samples.
            int nLenInput = env->GetArrayLength(dataIn);
            // Pre-calc the potential output size so buffers are grown just
            // once per invocation. This avoids reallocations mid-conversion
            // that could stall audio for TalkBack users.
            int nLenOutput =
                    ceil((double) (((nLenInput / 2.0) * (outSampleFreq * outChannels)) /
                                   inSampleFreq));
            if (!AllocBuffers(nLenInput, nLenOutput, inSampleFreq, outSampleFreq, inChannels,
                         outChannels)) {
                CGlobalTools::AndroidLog(
                                        "com.khanenoor.parsavatts",
                                        "Allocation failed while preparing resample buffers");
                return nullptr;
            }
            //V10 in https://developer.android.com/training/articles/perf-jni#java
            //say instead of get and memcpy and release use this function
            //byteDataIn = env->GetByteArrayElements(dataIn, nullptr);
            env->GetByteArrayRegion(dataIn, 0, mLenInput, reinterpret_cast<jbyte*>(mShortInput) );
            /*if (byteDataIn == nullptr) {
                CGlobalTools::AndroidLog(
                                    "com.khanenoor.parsavatts",
                                    "resample byteDataIn== nullptr");

            } else*/ {
                // Promote input samples to float so libsamplerate can process
                // them; keep a sentinel value to prevent reads past the end of
                // the buffer.
                src_short_to_float_array((short *) mShortInput, mFloatInput,
                                         (int) (mLenInput / sizeof(short)));
                mFloatInput[(int) mLenInput / sizeof(short)] = 0.0F;

                // release JNI objects
                // If you are using GetByteArrayElements you have to call ReleaseByteArrayElements after you are done with the array in JNI, because the JVM will prevent the freeing of this array in java until you do so. Please post the code to get a clearer idea
                // https://stackoverflow.com/questions/6894686/freeing-jni-references-from-memory
                //This below line cause sigsegv error , dataIn released in function that called no?
                /*
                env->
                            ReleaseByteArrayElements(dataIn, byteDataIn,
                                                     0);
                */
                src_reset(mPointerSRCState);
                // Configure the SRC_DATA block for this request. We reset the
                // state every call to avoid cross-request artifacts when
                // sample rates change rapidly.
                src_data.
                        end_of_input = 0;
                src_data.
                        input_frames = (int) (mLenInput / (sizeof(short) * inChannels));
                src_data.
                        data_in = mFloatInput;
                src_data.
                        data_out = mFloatOutput;
                //INFO_LOG(L"m_pTargetWaveFormat->nSamplesPerSec is %d %d", m_pTargetWaveFormat->nSamplesPerSec,m_pTargetWaveFormat->nChannels);
                src_data.
                        src_ratio = (1.0 * outSampleFreq) / inSampleFreq;
                src_data.
                        output_frames = mLenOutput / outChannels;
                /*if (nMessagePrintCounter < 3) {
                    CGlobalTools::AndroidLog(
                                        "com.khanenoor.parsavatts",
                                        "src_ratio : %f output_frames : %ld mLenInput:%d input_frames:%ld inSampleFreq: %d outSampleFreq:%d mLenOutput:%d threadId:0x%x",
                                        src_data.src_ratio, src_data.output_frames, mLenInput,
                                        src_data.input_frames, inSampleFreq, outSampleFreq,
                                        mLenOutput, std::this_thread::get_id());
                }*/
                nMessagePrintCounter++;
                if (src_data.src_ratio == 1.0) {
                    // When the input and output rates match, bypass
                    // libsamplerate and copy bytes directly for maximum speed.
                    ExceptionCheck(env);
                    dataOut = env->NewByteArray((jsize) (mLenInput));
                    //ExceptionCheck(env);//v63 to become faster
                    if (dataOut == nullptr) {
                        CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            "No memory could be allocated for buffer");

                        //return dataOut;
                    } else {
                        env->
                                SetByteArrayRegion(dataOut,
                                                   0, mLenInput, (jbyte *) (mShortInput));
                        //ExceptionCheck(env); //v63 to become faster
                        /*CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            "src_data.src_ratio == 1.0");
                        */
                    }
                } else {
                    /*CGlobalTools::AndroidLog(
                                        "com.khanenoor.parsavatts",
                                        "resample section1");
                    */

                    // Drive libsamplerate until the output buffer is full or
                    // the converter reports no more frames. This loop is
                    // intentionally tight to minimize latency spikes.
                    while (output_count < mLenOutput) {
                        if ((
                                (nSRCErrorCode = src_process(mPointerSRCState, &src_data)) != 0
                        )) {
                            //printf ("\nError : %s\n", src_strerror (error)) ;
                            CGlobalTools::AndroidLog(
                                                "com.khanenoor.parsavatts",
                                                "src_process error %d %s", nSRCErrorCode,
                                                src_strerror(nSRCErrorCode));

                        };

                        //dyn_buf.Put(mShortOutput, src_data.output_frames_gen);

                        //MN m_ullAudioOff += src_data.output_frames_gen;
                        //hr = m_pOutputSite->Write(mShortOutput, src_data.output_frames_gen * 2, NULL);

                        //if(hr != S_OK)
                        //return 1;

                        // Terminate if done.
                        if (src_data.output_frames_gen == 0)
                            break;
                        if (output_count + src_data.output_frames_gen <= mLenOutput) {
                            // ISSUE: multiplying the offset by sizeof(float) already advances the
                            // pointer in element-sized steps, so the extra sizeof(float) factor
                            // shifts the destination by 4x and risks writing past the buffer end.
                            memcpy(mFloatOutputResult + output_count, mFloatOutput,
                                   sizeof(float) * src_data.output_frames_gen);
                            output_count += src_data.output_frames_gen;
                        }
                        //int max = apply_gain (src_data.data_out, src_data.output_frames_gen, m_pTargetWaveFormat->nChannels, max, *gain);

                        if (output_count > mLenOutput) {
                            CGlobalTools::AndroidLog(
                                                "com.khanenoor.parsavatts",
                                                "output_count>mLenOutput output_frames_gen: %ld output_count: %d mLenOutput: %d",
                                                src_data.output_frames_gen, output_count,
                                                mLenOutput);

                        }
                        src_data.data_in += src_data.input_frames_used * inChannels;
                        src_data.input_frames -= src_data.
                                input_frames_used;
                        /*CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            " src_data.input_frames: %ld input_frames_used: %ld",
                                            src_data.input_frames , src_data.input_frames_used  );*/

                    }
                    /*if (nMessagePrintCounter < 3) {
                        CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            " output_frames_gen: %ld output_count: %d mLenOutput: %d",
                                            src_data.output_frames_gen, output_count, mLenOutput);
                    }*/
                    /*CGlobalTools::AndroidLog(
                                        "com.khanenoor.parsavatts",
                                        "resample section2");
                    */
                   // ISSUE: gain is applied across the full buffer even when output_count
                   // reports fewer valid frames, so stale data past output_count is scaled
                   // and later returned to Java.
                   correctVolume(mFloatOutputResult,output_count,volumeRatio);
                    src_float_to_short_array(mFloatOutputResult, mShortOutput, mLenOutput);
                    // if each frame was 16 bits per sample, each sample has two chanel, them each frame has 2 * 16 bits length
                    //V1: always output_count == mLenOutput
                    //V2: insert Load Unload, Alloc, Release functions , now sometimes output_count = mLenOutput - 1
                    //ExceptionCheck(env); //v63 to become faster
                    dataOut = env->NewByteArray((jsize) (output_count * sizeof(short)));
                    //ExceptionCheck(env);
                    if (dataOut == nullptr) {
                        CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            "No memory could be allocated for buffer");

                        //return dataOut;
                    } else {
                        env->
                                SetByteArrayRegion(dataOut,
                                                   0, (jsize) (output_count * sizeof(short)),
                                                   reinterpret_cast
                                                           <const jbyte *>(mShortOutput));
                                //ExceptionCheck(env);
                    }
                }
            }
        }
    }
    catch (...) {
        CGlobalTools::AndroidLog(
                            "com.khanenoor.parsavatts",
                            "Catch Exception");

        /* Oops I missed identifying this exception! */
        /*jclass jc = env->FindClass("java/lang/Error");
        if (jc)
            env->ThrowNew(jc, "Unidentified exception => "
                              "Improve rethrow_cpp_exception_as_java_exception()");
        */
    }
    //env->DeleteLocalRef(dataIn);
    //pthread_mutex_unlock(&mThreadCountLock);
    /*CGlobalTools::AndroidLog(
                        "com.khanenoor.parsavatts",
                        "resample section3");
    */
    /*if (dataIn != nullptr) {
        env->ReleaseByteArrayElements(dataIn, byteDataIn,
                                      0);
        ExceptionCheck(env);
    }*/
    return dataOut;

}
// Apply a per-call volume multiplier so callers can adjust amplitude without
// adding an extra processing pass in Java.
void correctVolume(float *buf,int len,float volumeRatio){
    for(int n=0;n<len;n++){
        buf[n] = buf[n] * volumeRatio;
    }
}
void releaseBuffers() {
    if (mShortInput != nullptr) {
        free(mShortInput);
        mShortInput = nullptr;
    }
    if (mFloatInput != nullptr) {
        free(mFloatInput);
        mFloatInput = nullptr;
    }
    if (mFloatOutput != nullptr) {
        free(mFloatOutput);
        mFloatOutput = nullptr;
    }
    if (mShortOutput != nullptr) {
        free(mShortOutput);
        mShortOutput = nullptr;
    }
    if (mFloatOutputResult != nullptr) {
        free(mFloatOutputResult);
        mFloatOutputResult = nullptr;
    }
    mLenOutput = 0;
    mLenInput = 0;
}

bool AllocBuffers(int len_input, int len_output, int inSampleFreq,
                  int outSampleFreq,
                  int intChannels,
                  int outChannels) {
    if (len_input == mLenInput && mLenOutput == len_output)
        return true;
    releaseBuffers();
    mLenInput = len_input;
    mLenOutput = len_output;
    // Allocate per-invocation scratch buffers. Keeping these native prevents
    // repeated crossings over the JNI boundary for every frame.
    mShortInput = (short *) malloc(sizeof(short) * (mLenInput / sizeof(short)));
    mFloatInput = (float *) malloc(sizeof(float) * (mLenInput / sizeof(short) + 1));
    mFloatOutput = (float *) malloc(sizeof(float) * (mLenOutput));
    mShortOutput = (short *) malloc(sizeof(short) * (mLenOutput));
    mFloatOutputResult = (float *) malloc(sizeof(float) * (mLenOutput));

    if (mShortInput == nullptr || mFloatInput == nullptr || mFloatOutput == nullptr ||
        mShortOutput == nullptr || mFloatOutputResult == nullptr) {
        CGlobalTools::AndroidLog(
                                "com.khanenoor.parsavatts",
                                "Failed to allocate resample buffers");
        releaseBuffers();
        return false;
    }

    return true;
}

void loadResample(jint inSampleFreq,
                  jint outSampleFreq,
                  jint intChannels,
                  jint outChannels) {
    int nSRCErrorCode;
    if (mIsLoaded) {
        return;
    }
    /*CGlobalTools::AndroidLog(
                        "com.khanenoor.parsavatts",
                        "loadResample");
    */
    if (mPointerSRCState == nullptr) {
        //mPointerSRCState = src_new(SRC_LINEAR, outChannels, &nSRCErrorCode);
        // SRC_SINC_MEDIUM_QUALITY : xesh xesh seda peyda mikonad
        // SRC_SINC_FASTEST : xesh xesh seda peyda mikonad
        // SRC_ZERO_ORDER_HOLD : work , but khane noor say xash darad va linear is better
        mPointerSRCState = src_new(SRC_LINEAR, outChannels, &nSRCErrorCode);

        if (mPointerSRCState == nullptr) {
            //MessageBoxW(NULL, L"SRC error", 0, MB_OK | MB_ICONERROR);
            CGlobalTools::AndroidLog(
                                "com.khanenoor.parsavatts",
                                "mPointerSRCState == NULL Err:%d",nSRCErrorCode);


        }
        mIsLoaded = true;
    }
}

extern "C" JNIEXPORT void JNICALL
Java_com_khanenoor_parsavatts_engine_EnTts_loadResample(JNIEnv *env, jobject thiz, int inSampleFreq,
                                                 int outSampleFreq,
                                                 int intChannels,
                                                 int outChannels) {
    loadResample(inSampleFreq, outSampleFreq, intChannels, outChannels);
}

void unloadResample() {
    //pthread_mutex_lock(&mThreadCountLock);
    if (mPointerSRCState != nullptr) {
        /*CGlobalTools::AndroidLog(
                            "com.khanenoor.parsavatts",
                            "unloadResample");
        */
        src_delete(mPointerSRCState);
        mPointerSRCState = nullptr;
    }
    releaseBuffers();
    mIsLoaded = false;
    //pthread_mutex_unlock(&mThreadCountLock);
    //pthread_mutex_lock(&mThreadCountLock);
    //pthread_mutex_unlock(&mThreadCountLock);
}

extern "C" JNIEXPORT void JNICALL
Java_com_khanenoor_parsavatts_engine_EnTts_unloadResample(JNIEnv *env, jobject thiz) {
    unloadResample();
}
bool ExceptionCheck(JNIEnv *env){
    jboolean flag = env->ExceptionCheck();
    if (flag) {
        env->ExceptionDescribe();
        env->ExceptionClear();
        /* code to handle exception */
        CGlobalTools::AndroidLog(
                            "com.khanenoor.parsavatts",
                            "ExceptionCheck return true");
        return true;
    }
    return false;
}
/////////////////// Native Buffer
extern "C" JNIEXPORT jobject
JNICALL Java_com_khanenoor_parsavatts_engine_EnTts_resampleNative(JNIEnv *env, jobject thiz, jobject
dataIn,
                                                            jint inSampleFreq,
                                                            jint outSampleFreq,
                                                            jint inChannels,
                                                            jint outChannels,
                                                            jfloat volumeRatio
) {
    SRC_DATA src_data;
    int nSRCErrorCode;
    jobject dataOut = nullptr;
    jbyte *byteDataIn = nullptr;
    try {
        //pthread_mutex_lock(&mThreadCountLock);
        if (mPointerSRCState != nullptr) {
            if (dataIn == nullptr) {
                CGlobalTools::AndroidLog(
                        "com.khanenoor.parsavatts",
                        "resampleNative received null input buffer");
                return nullptr;
            }
            int output_count = 0;
            // Direct buffers let Java manage the input backing array while
            // native code reuses floating-point scratch space. This keeps
            // repeated playback snappy without extra copies.
            short *nShortInput = (short *)env->GetDirectBufferAddress(dataIn);

            if (nShortInput == nullptr) {
                CGlobalTools::AndroidLog(
                        "com.khanenoor.parsavatts",
                        "resampleNative expected a direct buffer but got null address");
                return nullptr;
            }

            //nLenInput is size in Bytes

            int nLenInput = (int)env->GetDirectBufferCapacity(dataIn);
            if (nLenInput <= 0) {
                CGlobalTools::AndroidLog(
                        "com.khanenoor.parsavatts",
                        "resampleNative received empty input buffer");
                return nullptr;
            }
            /*CGlobalTools::AndroidLog(
                                "com.khanenoor.parsavatts",
                                "resampleNative nLenInput:%d",nLenInput);
            */
             int nLenOutput =
                    ceil((double) (((nLenInput / 2.0) * (outSampleFreq * outChannels)) /
                                   inSampleFreq));
            if (!AllocBuffers_native(nLenInput, nLenOutput, inSampleFreq, outSampleFreq, inChannels,
                         outChannels)) {
                CGlobalTools::AndroidLog(
                                        "com.khanenoor.parsavatts",
                                        "Allocation failed while preparing native resample buffers");
                return nullptr;
            }
            //V10 in https://developer.android.com/training/articles/perf-jni#java
            //say instead of get and memcpy and release use this function
            //byteDataIn = env->GetByteArrayElements(dataIn, nullptr);
            //env->GetByteArrayRegion(dataIn, 0, mLenInput, reinterpret_cast<jbyte*>(nShortInput) );
            /*if (byteDataIn == nullptr) {
                CGlobalTools::AndroidLog(
                                    "com.khanenoor.parsavatts",
                                    "resample byteDataIn== nullptr");

            } else*/ {
                src_short_to_float_array((short *) nShortInput, mFloatInput,
                                         (int) (nLenInput / sizeof(short)));
                mFloatInput[(int) nLenInput / sizeof(short)] = 0.0F;

                // release JNI objects
                // If you are using GetByteArrayElements you have to call ReleaseByteArrayElements after you are done with the array in JNI, because the JVM will prevent the freeing of this array in java until you do so. Please post the code to get a clearer idea
                // https://stackoverflow.com/questions/6894686/freeing-jni-references-from-memory
                //This below line cause sigsegv error , dataIn released in function that called no?
                /*
                env->
                            ReleaseByteArrayElements(dataIn, byteDataIn,
                                                     0);
                */
                src_reset(mPointerSRCState);
                src_data.
                        end_of_input = 0;
                src_data.
                        input_frames = (int) (nLenInput / (sizeof(short) * inChannels));
                src_data.
                        data_in = mFloatInput;
                src_data.
                        data_out = mFloatOutput;
                //INFO_LOG(L"m_pTargetWaveFormat->nSamplesPerSec is %d %d", m_pTargetWaveFormat->nSamplesPerSec,m_pTargetWaveFormat->nChannels);
                src_data.
                        src_ratio = (1.0 * outSampleFreq) / inSampleFreq;
                src_data.
                        output_frames = mLenOutput / outChannels;
                /*if (nMessagePrintCounter < 3) {
                    CGlobalTools::AndroidLog(
                                        "com.khanenoor.parsavatts",
                                        "src_ratio : %f output_frames : %ld mLenInput:%d input_frames:%ld inSampleFreq: %d outSampleFreq:%d mLenOutput:%d threadId:0x%x",
                                        src_data.src_ratio, src_data.output_frames, mLenInput,
                                        src_data.input_frames, inSampleFreq, outSampleFreq,
                                        mLenOutput, std::this_thread::get_id());
                }*/
                //nMessagePrintCounter++;
                if (src_data.src_ratio == 1.0) {
                    //mLenInput is as byte count
                    //ExceptionCheck(env);
                    //dataOut = env->NewByteArray((jsize) (mLenInput));
                    dataOut = env->NewDirectByteBuffer(nShortInput, nLenInput);
                    //ExceptionCheck(env);
                    if (dataOut == nullptr) {
                        CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            "No memory could be allocated for buffer");

                        //return dataOut;
                    } else {
                        /*
                        env->
                                SetByteArrayRegion(dataOut,
                                                   0, mLenInput, (jbyte *) (nShortInput));
                        */
                        // ExceptionCheck(env);
                        /*CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            "src_data.src_ratio == 1.0");
                        */
                    }
                } else {
                    /*CGlobalTools::AndroidLog(
                                        "com.khanenoor.parsavatts",
                                        "resample section1");
                    */

                    while (output_count < mLenOutput) {
                        if ((
                                (nSRCErrorCode = src_process(mPointerSRCState, &src_data)) != 0
                        )) {
                            //printf ("\nError : %s\n", src_strerror (error)) ;
                            CGlobalTools::AndroidLog(
                                                "com.khanenoor.parsavatts",
                                                "src_process error %d %s", nSRCErrorCode,
                                                src_strerror(nSRCErrorCode));

                        };

                        //dyn_buf.Put(mShortOutput, src_data.output_frames_gen);

                        //MN m_ullAudioOff += src_data.output_frames_gen;
                        //hr = m_pOutputSite->Write(mShortOutput, src_data.output_frames_gen * 2, NULL);

                        //if(hr != S_OK)
                        //return 1;

                        // Terminate if done.
                        if (src_data.output_frames_gen == 0)
                            break;
                        if (output_count + src_data.output_frames_gen <= mLenOutput) {
                            memcpy(mFloatOutputResult + output_count * sizeof(float), mFloatOutput,
                                   sizeof(float) * src_data.output_frames_gen);
                            output_count += src_data.output_frames_gen;
                        }
                        //int max = apply_gain (src_data.data_out, src_data.output_frames_gen, m_pTargetWaveFormat->nChannels, max, *gain);

                        if (output_count > mLenOutput) {
                            CGlobalTools::AndroidLog(
                                                "com.khanenoor.parsavatts",
                                                "output_count>mLenOutput output_frames_gen: %ld output_count: %d mLenOutput: %d",
                                                src_data.output_frames_gen, output_count,
                                                mLenOutput);

                        }
                        src_data.data_in += src_data.input_frames_used * inChannels;
                        src_data.input_frames -= src_data.
                                input_frames_used;
                        /*CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            " src_data.input_frames: %ld input_frames_used: %ld",
                                            src_data.input_frames , src_data.input_frames_used  );*/

                    }
                    /*if (nMessagePrintCounter < 3) {
                        CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            " output_frames_gen: %ld output_count: %d mLenOutput: %d",
                                            src_data.output_frames_gen, output_count, mLenOutput);
                    }*/
                    /*CGlobalTools::AndroidLog(
                                        "com.khanenoor.parsavatts",
                                        "resample section2");
                    */
                    correctVolume(mFloatOutputResult,output_count,volumeRatio);
                    src_float_to_short_array(mFloatOutputResult, mShortOutput, mLenOutput);
                    // if each frame was 16 bits per sample, each sample has two chanel, them each frame has 2 * 16 bits length
                    //V1: always output_count == mLenOutput
                    //V2: insert Load Unload, Alloc, Release functions , now sometimes output_count = mLenOutput - 1
                    //ExceptionCheck(env);
                    dataOut = env->NewDirectByteBuffer(mShortOutput, output_count * sizeof(short));
                    //dataOut = env->NewByteArray((jsize) (output_count * sizeof(short)));
                    //ExceptionCheck(env);
                    if (dataOut == nullptr) {
                        CGlobalTools::AndroidLog(
                                            "com.khanenoor.parsavatts",
                                            "No memory could be allocated for buffer");

                        //return dataOut;
                    } else {
                        /*env->
                                SetByteArrayRegion(dataOut,
                                                   0, (jsize) (output_count * sizeof(short)),
                                                   reinterpret_cast
                                                           <const jbyte *>(mShortOutput));
                        */
                         //ExceptionCheck(env);
                    }
                }
            }
        }
    }
    catch (...) {
        CGlobalTools::AndroidLog(
                            "com.khanenoor.parsavatts",
                            "Catch Exception");

        /* Oops I missed identifying this exception! */
        /*jclass jc = env->FindClass("java/lang/Error");
        if (jc)
            env->ThrowNew(jc, "Unidentified exception => "
                              "Improve rethrow_cpp_exception_as_java_exception()");
        */
    }
    //env->DeleteLocalRef(dataIn);
    //pthread_mutex_unlock(&mThreadCountLock);
    /*CGlobalTools::AndroidLog(
                        "com.khanenoor.parsavatts",
                        "resample section3");
    */
    /*if (dataIn != nullptr) {
        env->ReleaseByteArrayElements(dataIn, byteDataIn,
                                      0);
        ExceptionCheck(env);
    }*/
    return dataOut;

}
bool AllocBuffers_native(int len_input, int len_output, int inSampleFreq,
                  int outSampleFreq,
                  int intChannels,
                  int outChannels) {
    if (len_input == mLenInput && mLenOutput == len_output)
        return true;
    releaseBuffers();
    mLenInput = len_input;
    mLenOutput = len_output;
    //mShortInput = (short *) malloc(sizeof(short) * (mLenInput / sizeof(short)));
    mFloatInput = (float *) malloc(sizeof(float) * (mLenInput / sizeof(short) + 1));
    mFloatOutput = (float *) malloc(sizeof(float) * (mLenOutput));
    mShortOutput = (short *) malloc(sizeof(short) * (mLenOutput));
    mFloatOutputResult = (float *) malloc(sizeof(float) * (mLenOutput));

    if (mFloatInput == nullptr || mFloatOutput == nullptr || mShortOutput == nullptr ||
        mFloatOutputResult == nullptr) {
        CGlobalTools::AndroidLog(
                                "com.khanenoor.parsavatts",
                                "Failed to allocate native resample buffers");
        releaseBuffers();
        return false;
    }

    return true;
}
